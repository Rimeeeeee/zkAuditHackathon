import { waitForNewAttestationEvent } from '../helpers';
import { handleTransactionEvents } from './events';
import { TransactionStatus, TransactionType, ZkVerifyEvents, } from '../../enums';
import { handleError } from './errors';
const safeEmit = (emitter, event, data) => {
    try {
        emitter.emit(event, data);
    }
    catch (error) {
        console.debug(`Failed to emit event ${event}:`, error);
    }
};
const handleInBlock = async (api, events, transactionInfo, setAttestationId, emitter, transactionType) => {
    if (transactionInfo.status === TransactionStatus.Error) {
        return;
    }
    transactionInfo.status = TransactionStatus.InBlock;
    const updatedTransactionInfo = handleTransactionEvents(api, events, transactionInfo, emitter, setAttestationId, transactionType);
    Object.assign(transactionInfo, updatedTransactionInfo);
    safeEmit(emitter, ZkVerifyEvents.IncludedInBlock, transactionInfo);
};
const handleFinalized = async (api, transactionInfo, dispatchError, emitter, transactionType) => {
    if (transactionInfo.status === TransactionStatus.Error) {
        return;
    }
    if (dispatchError) {
        handleError(emitter, api, transactionInfo, dispatchError);
        return;
    }
    transactionInfo.status = TransactionStatus.Finalized;
    if (transactionType === TransactionType.Verify) {
        const verifyTransactionInfo = transactionInfo;
        if (verifyTransactionInfo.attestationId) {
            safeEmit(emitter, ZkVerifyEvents.Finalized, verifyTransactionInfo);
        }
        else {
            const errorMsg = 'Finalized but no attestation ID found.';
            safeEmit(emitter, ZkVerifyEvents.ErrorEvent, {
                ...verifyTransactionInfo,
                error: errorMsg,
            });
        }
    }
    else if (transactionType === TransactionType.VKRegistration) {
        const vkRegistrationInfo = transactionInfo;
        if (vkRegistrationInfo.statementHash) {
            safeEmit(emitter, ZkVerifyEvents.Finalized, vkRegistrationInfo);
        }
        else {
            const errorMsg = 'Finalized but no statement hash found.';
            safeEmit(emitter, ZkVerifyEvents.ErrorEvent, {
                ...vkRegistrationInfo,
                error: errorMsg,
            });
        }
    }
};
export const handleTransaction = async (api, submitExtrinsic, account, signer, emitter, options, transactionType) => {
    const { proofOptions: { proofType }, waitForNewAttestationEvent: shouldWaitForAttestation = false, nonce = -1, // accountNextIndex preferred shortcut if not set by user.
     } = options;
    const transactionInfo = {
        blockHash: '',
        proofType,
        status: TransactionStatus.Pending,
        txHash: undefined,
        extrinsicIndex: undefined,
        feeInfo: undefined,
        weightInfo: undefined,
        txClass: undefined,
    };
    const setAttestationId = (id) => {
        transactionInfo.attestationId = id;
    };
    return new Promise((resolve, reject) => {
        const cancelTransaction = (error) => {
            if (transactionInfo.status !== TransactionStatus.Error) {
                transactionInfo.status = TransactionStatus.Error;
                try {
                    if (error instanceof Error) {
                        handleError(emitter, api, transactionInfo, error, true);
                    }
                    else {
                        handleError(emitter, api, transactionInfo, new Error(String(error)), true);
                    }
                }
                catch (err) {
                    reject(err);
                    return;
                }
            }
        };
        const finalizeTransaction = async (result) => {
            if (transactionInfo.status === TransactionStatus.Error) {
                return;
            }
            try {
                await handleFinalized(api, transactionInfo, result.dispatchError, emitter, transactionType);
                if (transactionType === TransactionType.Verify &&
                    shouldWaitForAttestation &&
                    transactionInfo.attestationId) {
                    try {
                        transactionInfo.attestationEvent =
                            await waitForNewAttestationEvent(api, transactionInfo.attestationId, emitter);
                        transactionInfo.attestationConfirmed =
                            true;
                    }
                    catch (error) {
                        cancelTransaction(error);
                        return;
                    }
                }
                resolve(transactionInfo);
            }
            catch (error) {
                cancelTransaction(error);
            }
        };
        performSignAndSend(submitExtrinsic, account, signer ? { signer, nonce } : { nonce }, async (result) => {
            if (transactionInfo.status === TransactionStatus.Error) {
                return;
            }
            try {
                if (result.status.isBroadcast) {
                    safeEmit(emitter, ZkVerifyEvents.Broadcast, {
                        txHash: result.txHash.toString(),
                    });
                }
                if (result.status.isInBlock) {
                    transactionInfo.txHash = result.txHash.toString();
                    transactionInfo.blockHash = result.status.asInBlock.toString();
                    await handleInBlock(api, result.events, transactionInfo, setAttestationId, emitter, transactionType);
                }
                if (result.status.isFinalized) {
                    await finalizeTransaction(result);
                }
                else if (result.status.isInvalid) {
                    throw new Error('Transaction is invalid.');
                }
            }
            catch (error) {
                cancelTransaction(error);
            }
        }).catch((error) => {
            cancelTransaction(error);
        });
    });
};
function performSignAndSend(submitExtrinsic, account, options, callback) {
    if (typeof account === 'string' && options?.signer) {
        return submitExtrinsic.signAndSend(account, options, callback);
    }
    else if (typeof account !== 'string') {
        if (options) {
            return submitExtrinsic.signAndSend(account, options, callback);
        }
        else {
            return submitExtrinsic.signAndSend(account, callback);
        }
    }
    else {
        throw new Error('Unsupported account or signer type.');
    }
}
